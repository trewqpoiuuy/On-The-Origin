cpp=""
tab=0

#import clipboard

def rotate(l,n):
    return l[n:] + l[:n]

def transform(a, b, c, t):
    v=[a,b,c]
    return (v[t[0]],v[t[1]],v[t[2]])

def addline(line):
    global cpp,tab
    cpp+="\t"*tab
    cpp+=line.replace("+-","-").replace("+0;", ";  ").replace("+0]","  ]")
    cpp+="\n"

def addlines(lines):
    for line in lines.split("\n"):
        addline(line)

addline("//////// C++ Generated by voxelcuberule.py ////////")

for d in [0,1,2]:
    t=rotate([0,1,2],d)
    varname = ['z','y','x'][d]
    for s in [-1,1]:
        compare = ['<','>'][(s+1)/2]
        #addline("if (d_solid[vdaddr(x+%d,y+%d,z+%d)]==0 && camera_%c%c%c) {" % (transform(0,0,s,t)+(varname, compare, varname)))
        addline("if (getVoxelAtCoord(%d,%d,%d)->solid==0) {" % (transform(0,0,s,t)))
        tab+=1
        ### Calculate normals with directions:
        nmr = 2 # range for checking surroundings for voxel calculations
        #starts = transform(-nmr,-nmr,           -nmr+((-s+1)/2)            ,t)
        #ends = transform(nmr,nmr,                nmr+((-s+1)/2)-1          ,t)
        starts = (-nmr,-nmr,-nmr)
        ends = (nmr,nmr,nmr)
        addline("float normalx=0;")
        addline("float normaly=0;")
        addline("float normalz=0;")
        if True:
            addline("for (int oz=%d; oz<=%d; oz++) {" % (starts[2],ends[2]))
            tab+=1
            addline("for (int oy=%d; oy<=%d; oy++) {" % (starts[1],ends[1]))
            tab+=1
            addline("for (int ox=%d; ox<=%d; ox++) {" % (starts[0],ends[0]))
            tab+=1
            addline("normalx-=ox*(getVoxelAtCoord(x+ox,y+oy,z+oz)->solid);")
            addline("normaly-=oy*(getVoxelAtCoord(x+ox,y+oy,z+oz)->solid);")
            addline("normalz-=oz*(getVoxelAtCoord(x+ox,y+oy,z+oz)->solid);")
            tab-=1
            addline("}")
            tab-=1
            addline("}")
            tab-=1
            addline("}")
        addline("normal%c+=%f;" % (varname,s*nmr**3/4.0))
        addlines("float m=sqrt(normalx*normalx+normaly*normaly+normalz*normalz);\nif (m!=0) {\n\tnormalx = normalx/m;\n\tnormaly = normaly/m;\n\tnormalz = normalz/m;\n}")

        ### Following generates verts
        for (a,b) in [(1,1),(1,-1),(-1,-1),(-1,1)]:
            #addline("// normalbufferdata[i  ] = %d; normalbufferdata[i+1] = %d; normalbufferdata[i+2] = %d;" % transform(0,0,s,t))
            addline("chunkp->colors.push_back(%s); chunkp->colors.push_back(%s); chunkp->colors.push_back(%s);" % ("r","g","b"))
            addline("chunkp->normals.push_back(normalx); chunkp->normals.push_back(normaly); chunkp->normals.push_back(normalz);")
            addline("chunkp->verts.push_back(x+%.1f); chunkp->verts.push_back(y+%.1f); chunkp->verts.push_back(z+%.1f);" % transform(s*.5*a, .5*b, s*.5,t))
            #addline("i+=nb;")
        tab-=1
        addline("}")

addline("////////       End of generated code       ////////")

print cpp
#clipboard.copy(cpp)
