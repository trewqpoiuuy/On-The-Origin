/*
 * World.cpp
 *
 *  Created on: Feb 10, 2014
 *      Author: Theron
 */

#include "World.h"

#include <assert.h>
#include "../Misc/utils.h"

namespace World {

World::World() {
	settings.ncwx = 512;
	settings.ocwx = 256;
	settings.ncwy = 512;
	settings.ocwy = 256;
	settings.ncwz = 32;
	settings.ocwz = 16;
	settings.nvcx = 8;
	settings.nvcy = 8;
	settings.nvcz = 8;
	settings.voxelsize = 1.2;
	init();
}

World::World(WorldSettings _settings) {
	settings = _settings;
	init();
}

void World::init() {
	chunkpdata.resize(settings.ncwx*settings.ncwy*settings.ncwz);
}

int sc(int x, int y, int z, int xw, int yw, int zw) {
	return x+y*xw+z*xw*yw;
}

int World::scCW(int cx, int cy, int cz) {
	return (cx+settings.ocwx)+(cy+settings.ocwy)*settings.ncwx+(cz+settings.ocwz)*settings.ncwx*settings.ncwy;
}

int World::scVC(int vx, int vy, int vz) {
	return vx+vy*settings.nvcx+vz*settings.nvcx*settings.nvcy;
}

int World::VCtoCC(float d, int nvcd) {
	return d/nvcd;
}

int World::VCrelC(float d, int nvcd) {
	return int(d)%nvcd;
}

void World::createChunkAtCC(int cx, int cy, int cz) {
	Chunk chunk;
	chunkstorage.push_back(chunk);
	Chunk* newchunkp = &chunkstorage.back();
	newchunkp->voxeldata.resize(settings.nvcx*settings.nvcy*settings.nvcz);
	chunkpdata.at(scCW(cx,cy,cz)) = newchunkp;
}

Chunk* World::getCreateChunkPAtCC(int cx, int cy, int cz) {
	Chunk* chunkp = chunkpdata.at(scCW(cx,cy,cz));
	if (!chunkp) {
		createChunkAtCC(cx, cy, cz);
	}
	return chunkpdata.at(scCW(cx,cy,cz));
}

Chunk* World::getCreateChunkPAtVC(int x, int y, int z) {
	return getCreateChunkPAtCC(VCtoCC(x,settings.nvcx),VCtoCC(y,settings.nvcy),VCtoCC(z,settings.nvcz));
}

VData* World::getCreateVDataPAtVC(int x, int y, int z) {
	Chunk* chunkp = getCreateChunkPAtVC(x,y,z);
	int xrel = VCrelC(x,settings.nvcx);
	int yrel = VCrelC(y,settings.nvcy);
	int zrel = VCrelC(z,settings.nvcz);
	int p = scVC(xrel,yrel,zrel);
	int q = scVC(VCrelC(x,settings.nvcx),VCrelC(y,settings.nvcy),VCrelC(z,settings.nvcz));
	int r = scVC(0,0,0);
	int s = 0;  //todo clean up this debug mess
	assert (chunkp);
	return &chunkp->voxeldata.at(p);
}

VData* World::editDataPAt(float x, float y, float z) {
	getCreateChunkPAtVC(x,y,z)->update = true;
	return getCreateVDataPAtVC(x/settings.voxelsize,y/settings.voxelsize,z/settings.voxelsize);
}

void World::applyFuncInRange(void (*func)(float x, float y, float z, VData* datap), float x1, float y1, float z1, float x2, float y2, float z2) {
	for (int z=z1/settings.voxelsize; z<z2/settings.voxelsize; z++) {
		for (int y=y1/settings.voxelsize; y<y2/settings.voxelsize; y++) {
			for (int x=x1/settings.voxelsize; x<x2/settings.voxelsize; x++) {
				func(x*settings.voxelsize,y*settings.voxelsize,z*settings.voxelsize,editDataPAt(x,y,z));
			}
		}
	}
}

void World::generateNormalsInChunk(Chunk* chunkp) {
	for (int vz=chunkp->cz*settings.nvcz; vz<(chunkp->cz+1)*settings.nvcz; vz++) {
		for (int vy=chunkp->cy*settings.nvcy; vy<(chunkp->cy+1)*settings.nvcy; vy++) {
			for (int vx=chunkp->cx*settings.nvcx; vx<(chunkp->cx+1)*settings.nvcx; vx++) {
				VData* tvp = getCreateVDataPAtVC(vx,vy,vz);
				const int nrange=3;
				float normalx=0;
				float normaly=0;
				float normalz=0;
				for (int zo=-nrange; zo<nrange; zo++) {
					for (int yo=-nrange; yo<nrange; yo++) {
						for (int xo=-nrange; xo<nrange; xo++) {    /// Crude normal approximation by calculating weighting of voxels in nrange cubic neighborhood
							if (getCreateVDataPAtVC(vx+xo,vy+yo,vz+zo)->solid) {
								float dist=pythag(xo+0.5,yo+0.5,zo+0.5);
								float direcx = xo+0.5;
								float direcy = yo+0.5;
								float direcz = zo+0.5;
								normalize3p(&direcx,&direcy,&direcz);
								normalx+=direcx/dist;
								normaly+=direcy/dist;
								normalz+=direcz/dist;
							}
						}
					}
				}
				normalize3p(&normalx,&normaly,&normalz);
				tvp->xnormalc = normalx;
				tvp->ynormalc = normaly;
				tvp->znormalc = normalz;
			}
		}
	}
}

void World::generateVertsInChunk(Chunk* chunkp) {
	printf("Updating chunk with CC (%d,%d,%d)\n",chunkp->cx,chunkp->cy,chunkp->cz);
	DrawData* drawp = &chunkp->drawdata;
	drawp->colors.clear();
	drawp->normals.clear();
	drawp->verts.clear();
	for (int z=chunkp->cz*settings.nvcz; z<(chunkp->cz+1)*settings.nvcz; z++) {
		for (int y=chunkp->cy*settings.nvcy; y<(chunkp->cy+1)*settings.nvcy; y++) {
			for (int x=chunkp->cx*settings.nvcx; x<(chunkp->cx+1)*settings.nvcx; x++) {
				VData* tvp = getCreateVDataPAtVC(x,y,z);
				if (tvp->solid) {
					printf("Solid voxel detected at (%d,%d,%d)\n",x,y,z);
					GLfloat r = 1;
					GLfloat g = 1;
					GLfloat b = 1;
					//////// C++ Generated by voxelcuberule.py ////////
					if (getCreateVDataPAtVC(x+0,y+0,z-1)->solid==0) {
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z-0.5);
					}
					if (getCreateVDataPAtVC(x+0,y+0,z+1)->solid==0) {
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z+0.5);
					}
					if (getCreateVDataPAtVC(x+0,y-1,z+0)->solid==0) {
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z+0.5);
					}
					if (getCreateVDataPAtVC(x+0,y+1,z+0)->solid==0) {
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z-0.5);
					}
					if (getCreateVDataPAtVC(x-1,y+0,z+0)->solid==0) {
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,1)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,0,0)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,0)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(0,1,1)->znormalc);
						drawp->verts.push_back(x-0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z+0.5);
					}
					if (getCreateVDataPAtVC(x+1,y+0,z+0)->solid==0) {
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,1)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z+0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,1,0)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y+0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,0)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z-0.5);
						drawp->colors.push_back(r); drawp->colors.push_back(g); drawp->colors.push_back(b);
						drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->xnormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->ynormalc); drawp->normals.push_back(getCreateVDataPAtVC(1,0,1)->znormalc);
						drawp->verts.push_back(x+0.5); drawp->verts.push_back(y-0.5); drawp->verts.push_back(z+0.5);
					}
					////////       End of generated code       ////////
				}
			}
		}
	}
	printf("%d verts extracted\n",drawp->verts.size());
}

void World::drawChunk(Chunk* chunkp) {

}

void World::update() {
	printf("%d chunks exist\n",chunkstorage.size());
	unsigned int i;
	for (i=0; i<chunkstorage.size(); i++) {
		Chunk* chunkp=&chunkstorage.at(i);
		printf("Update chunk?  %d\n",chunkp->update);
		if (chunkp->update) {
			generateNormalsInChunk(chunkp);
			generateVertsInChunk(chunkp);
		}
	}
	printf("%d chunks processed in update\n",i);
}

void World::draw() {
	for (unsigned int i=0; i<chunkstorage.size(); i++) {
		Chunk* chunkp=&chunkstorage.at(i);
		drawChunk(chunkp);
	}
}

} /* namespace World */
